---
title: 슬랙 봇으로 Daily Report 자동화 만들기
categories: [뚝딱뚝딱]
tags: [JIRA, SLACK]
---


### 배경
우리 회사에서는 매일 업무 시작과 종료 시에 데일리 리포트를 작성한다.

업무 시작

<aside>
💡 0000.00.00 (월) 금일 업무 수행할 계획 [근무지: xxx오피스]

[ABC-1234] [BE] 테스트 코드 작성 estimated 1h / left 1h

</aside>

업무 종료

<aside>
💡 0000.00.00 (월) 금일 업무 수행한 내용 [근무지: xxx오피스]

[ABC-1234] [BE] 테스트 코드 작성 estimated 1h / left 1h / progress 1h --> left 0h [done]

</aside>

이렇게 작성하는 방식이다.

그런데 이러한 데일리 리포트가 작성할 때 팀에서 불편한 점이 많았다..

1. 날짜, 요일, 지라 넘버 등 오타가 많이 발생
    
    → 아무래도 사람이 작성하다 보니 맞지 않는 데일리 리포트가 작성되는 경우가 있어서 수정한 적이 종종 있었다.
    
2. 데일리 리포트 작성 자체를 잊어버리는 경우가 있음
    
    → 아침에 출근하자마자 이슈가 생겨서 회의를 하거나 코드 작성을 할 때 데일리 리포트를 까먹는 경우가 팀에서 생겼다.
    
3. 지라에 있는 정보인데 굳이..?
    
    → 데일리 리포트는 지라에 있는 내용을 거의 똑같이 수기로 옮기는 방식으로 작성한다. 그래서 지라에 똑같은 내용을 확인할 수 있는데 굳이 슬랙으로 메시지를 작성해야 하는가? 라는 의문이 들었다.
    

이러한 문제점들이 있어서 ‘그래 그냥 내가 하나 만들자! 그래도 개발자인데 이 정도는 자동화하자!!!’ 하고 삽질을 시작했다.

### 구현

먼저 구현 흐름은 이렇게 잡았다.

1. Jira API에서 원하는 이슈 정보 불러옴
    1. 데일리 리포트에 [진행 중]인 이슈와 오늘 완료한 [완료됨]의 이슈의 정보가 필요함
2. 불러온 이슈를 SpringBoot에서 가공
    1. 회사에서 사용하는 데일리 리포트 양식이 있었기 때문에 해당 양식으로 출력해야 했다.
    2. 이슈의 추정 시간, 소요 시간 등은 가져올 수 있지만 진행한 시간은 계산을 해야 했기 때문에 해당 로직도 추가했다.
3. 월 ~ 금 오전 09시, 오후 06시에 @Scheduler를 사용하여 메서드 실행
4. 메서드 리턴 값을 커스텀 슬랙 봇을 이용하여 채팅방에 전송

1) 먼저 프로젝트 생성을 한다.

- build.gradle

```groovy
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.2.3'
	id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.chaorda'
version = '0.0.1-SNAPSHOT'

java {
	sourceCompatibility = '17'
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation("com.slack.api:bolt:1.18.0")
	implementation("com.slack.api:bolt-servlet:1.18.0")
	implementation("com.slack.api:bolt-jetty:1.18.0")
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-webflux'
	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'io.projectreactor:reactor-test'
}

tasks.named('test') {
	useJUnitPlatform()
}
```

2) 지라에서 이슈 정보를 받아오자!

- 지라 이슈 정보를 담을 IssueDto를 생성하고 WebClient로 받아온다.
- 여기서 jql은  Jira Query Language이다.  Jira Issue 를 검색하기 위한 구조적인 언어다.
- 업무 시작, 업무 종료 시엔 다른 jql이 들어가야 하기 때문에 jql을 파라미터로 받아준다.
- 또한 webclient의 기본 세팅으로는 사이즈가 넘치기 때문에 설정도 바꿔준다.

```java
private IssueDto jiraWebClient(String jql) throws JsonProcessingException {
    ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(-1)) // to unlimited memory size
            .build();
    WebClient client = WebClient.builder()
            .baseUrl(JIRA_URL)
            .exchangeStrategies(exchangeStrategies)
            .defaultHeader(AUTHORIZATION, "Basic " + java.util.Base64.getEncoder().encodeToString((JIRA_USERNAME + ":" + JIRA_TOKEN).getBytes()))
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    String result = client.get()
            .uri("/rest/api/2/search?jql={jql}", jql)
            .retrieve()
            .bodyToFlux(String.class).blockFirst();
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(result, IssueDto.class);

}
```

3) 받아온 이슈 정보를 가공하자

여기서 참 많이 삽질을 했는데 방법 세 가지를 알아보자

- String 값으로 넣기
    - 단순하게 스트링 값을 입력해서 리턴하는 방식이다.
    - sb.append().apeend() ….
    - 일일이 타이핑 해야 하고 어렵고 지원 안되고 등등 하지 말자.
- Block template 이용하기
    - 슬랙에서는 메시지를 **Block template 를 이용하여 작성할 수 있다.**
    - 아래 링크를 클릭하면 템플릿을 만들어보고 사용할 수 있다.
        
        [](https://app.slack.com/block-kit-builder)
        
    - 하지만 결국 Json 형태를 스트링으로 리턴 해야 함으로 일일이 작성해야 한다는 점은 변함이 없다.
- 슬랙 api를 이용하여 blocks 이용하기
    - 슬랙 API 라이브러리를 추가해주면 blocks를 편하게 작성할 수 있다.
    
    ```java
    public void sendBlocks() throws IOException, SlackApiException {
            List<LayoutBlock> blocks = new ArrayList<>();
            IssueDto issueDto = jiraWebClient(END_JQL);
            blocks.add(section(section -> section.text(markdownText(helloChat()))));
            blocks.add(divider());
            blocks.add(section(section -> section.text(markdownText(title()))));
            blocks.add(section(section -> section.text(markdownText(makeEndMessage(issueDto)))));
            blocks.add(divider());
            blocks.add(section(section -> section.text(markdownText(endChat()))));
            MethodsClient methods = Slack.getInstance().methods(SLACK_TOKEN);
            ChatPostMessageRequest request = ChatPostMessageRequest.builder()
                    .channel(SLACK_CHANNEL)
                    .blocks(blocks)
                    .build();
            methods.chatPostMessage(request);
        }
    
    ```
    

4) 스케줄러를 사용하여 일정한 시간에 전송하자.

- 스케줄러를 추가해주자

```java
@SpringBootApplication
@EnableScheduling
public class DailyreportApplication {
	public static void main(String[] args) {
		SpringApplication.run(DailyreportApplication.class, args);
	}
}
```

- @Schedule 어노테이션을 추가한다.

```java
 @Scheduled(cron = "0 0 9 * * 1-5", zone = "Asia/Seoul") // 매일 오전 9시 실행
    public void sendBlocks() throws IOException, SlackApiException {
        List<LayoutBlock> blocks = new ArrayList<>();
        IssueDto issueDto = jiraWebClient(START_JQL);
        blocks.add(section(section -> section.text(markdownText(helloChat()))));
        blocks.add(divider());
        blocks.add(section(section -> section.text(markdownText(title()))));
        blocks.add(section(section -> section.text(markdownText(makeStartMessage(issueDto)))));
        blocks.add(divider());
        blocks.add(section(section -> section.text(markdownText(endChat()))));
        MethodsClient methods = Slack.getInstance().methods(SLACK_TOKEN);
        ChatPostMessageRequest request = ChatPostMessageRequest.builder()
                .channel(SLACK_CHANNEL)
                .blocks(blocks)
                .build();
        methods.chatPostMessage(request);
    }
```

5) 작성한 메시지를 슬랙 봇을 생성하여 채널에 전송하자

### 결과

성공적으로 메시지가 나오는 모습을 보인다.

![제목 없음.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f3f46391-2d7d-4cbc-9fe4-d9363de7a908/b341d5de-e44c-4a2b-a564-6f29991fe542/%EC%A0%9C%EB%AA%A9_%EC%97%86%EC%9D%8C.png)

여담)

데일리리포트 봇을 집에서 만들고 출근해서 “짜잔! 여러분 ~ 이제 편하게 사용하세요~” 라고 하려고 했지만.. CTO님이 Daily Report는 업무 내용을 슬랙에 공유하고 연구노트를 작성하는 등 문서화의 목적도 있지만 본인이 스스로 업무를 시작, 종료할 때 해당 업무를 파악하는 목적도 있다고 하셔서 결국 파기했다는 슬픈이야기..

그래도 API 연동을 해보고 슬랙봇을 커스텀 하는 경험도 했으니 만족! 😀
